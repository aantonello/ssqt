/**
 * @file
 * Declares the ss::columnt_t class.
 *
 * @author Alessandro Antonello <aantonello@paralaxe.com.br>
 * @date   dezembro 10, 2014
 * @since  Super Simple for Qt 5 1.2
 *
 * \copyright
 * This file is provided in hope that it will be useful to someone. It is
 * offered in public domain. You may use, modify or distribute it freely.
 *
 * The code is provided "AS IS". There is no warranty at all, of any kind. You
 * may change it if you like. Or just use it as it is.
 */
#ifndef __COLUMN_HPP_DEFINED__
#define __COLUMN_HPP_DEFINED__

#include <QString>
#include <QVariant>

namespace ss {

/**
 * \internal
 * Base implementation of a table column.
 * @since 1.2
 *//* --------------------------------------------------------------------- */
class column_t : public SSSharedT<column_t>
{
public:
    /** @name Constructors */ //@{
    // column_t(const QString &fieldName, QVariant::Type type);/*{{{*/
    /**
     * Constructs a column object setting its name and type.
     * @param fieldName Name of the column origin field.
     * @param type Data type of the value. This type is converted to one of
     * those found in the @ref ssqt_dao_constants module.
     * @since 1.2
     **/
    column_t(const QString &fieldName, QVariant::Type type);
    /*}}}*/
    // column_t(const column_t &column);/*{{{*/
    /**
     * Copy constructor.
     * @param column the original column to copy data from. All values are
     * duplicated except the reference counting.
     * @since 1.2
     **/
    column_t(const column_t &column);
    /*}}}*/
    // column_t(const QSqlField &field, const QSqlIndex &index = QSqlIndex());/*{{{*/
    /**
     * Initializing constructor.
     * @param field \c QSqlField with the original data.
     * @param index Optional. \c QSqlIndex with the indexes of the query or
     * table. Used to set properties of this object.
     * @since 1.2
     **/
    column_t(const QSqlField &field, const QSqlIndex &index = QSqlIndex());
    /*}}}*/
    //@}
public:
    /** @name Attributes */ //@{
    // bool required() const;/*{{{*/
    /**
     * Checks if this column is required.
     * Required columns are those set as <b>NOT NULL</b> in the database
     * schema. So a value must be set.
     * @returns \b true if a value for this column must be set. Otherwise \b
     * false.
     * @since 1.2
     **/
    bool required() const;
    /*}}}*/
    // bool readOnly() const;/*{{{*/
    /**
     * Check whether this column's value is read-only.
     * Almost no column in this library is read-only. Even those resulting
     * from a \c SELECT statement.
     * @returns \b true if the column's value cannot be changed. Otherwise \b
     * false.
     * @since 1.2
     **/
    bool readOnly() const;
    /*}}}*/
    // bool autoValue() const;/*{{{*/
    /**
     * Checks whether the value of this column can be generated by the
     * database driver or server.
     * Usually primary key columns have their values generated by the
     * database.
     * @returns \b true when the value of this column can be generated by the
     * database, otherwise \b false.
     * @since 1.2
     **/
    bool autoValue() const;
    /*}}}*/
    // bool indexed() const;/*{{{*/
    /**
     * Checks whether this column participates in an index.
     * The column can be the single index of the table or participate in
     * a multicolumn index.
     * @returns \b true if this column is indexed in the database. \b false
     * otherwise.
     * @since 1.2
     **/
    bool indexed() const;
    /*}}}*/
    // bool primaryKey() const;/*{{{*/
    /**
     * Whether this column is the primary key of its origin table.
     * Usually just the first column of a database table is the primary key.
     * Others drivers have columns with predefined names like "id" or "rowid".
     * @returns \b true if this column is a primary key. Otherwise \b false.
     * @since 1.2
     **/
    bool primaryKey() const;
    /*}}}*/
    // bool isNull() const;/*{{{*/
    /**
     * Whether the value of this column was not set.
     * When this operation returns \b true the \c value member is invalid.
     * @returns \b true if this column has no value. \b false otherwise.
     * @since 1.2
     **/
    bool isNull() const;
    /*}}}*/
    //@}
public:
    /** @name Properties */ //@{
    // uint dataType() const;/*{{{*/
    /**
     * Get the data type of this column's value.
     * @return A constant listed in the @ref ssqt_dao_constants module
     * defining a data type.
     * @since 1.2
     **/
    uint dataType() const;
    /*}}}*/
    // void dataType(uint type);/*{{{*/
    /**
     * Sets or changes the data type of this column.
     * @param type The new data type. A constant in the @ref
     * ssqt_dao_constants module defining a type.
     * @remarks This operation is useful to identify a column having
     * a timestamp information from the standard \c SS_DATA_TYPE_INT type. Or
     * to change a column of type \c SS_DATA_TYPE_TEXT to \c
     * SS_DATA_TYPE_DATE. Although this is not needed to convert values
     * between types.
     * @since 1.2
     **/
    void dataType(uint type);
    /*}}}*/
    // void setType(QVariant::Type type);/*{{{*/
    /**
     * Sets or changes the type of this column's value.
     * @param type A enumeration constant with the type information.
     * @remarks This member function should not be used. It is intended for
     * internal conversions only.
     * @since 1.2
     **/
    void setType(QVariant::Type type);
    /*}}}*/
    // int  precision() const;/*{{{*/
    /**
     * Retrieves the precision of this column's value.
     * @return An integer meaning the number of decimal places after the
     * floating point separator. This information is useful only for columns
     * of floating point numbers with fixed precision. Otherwise the result
     * value will be zero.
     * @since 1.2
     **/
    int  precision() const;
    /*}}}*/
    // void precision(int precis);/*{{{*/
    /**
     * Sets or changes the precision of this column's value.
     * @param precis The precision to set.
     * @remarks This operation is not meant to be used outside the scope of
     * this object. It is used to set the precision based on database
     * information only.
     * @since 1.2
     **/
    void precision(int precis);
    /*}}}*/
    //@}
public:
    /** @name Import & Export Operations */ //@{
    // void reset(const QSqlField &field, const QSqlIndex &index = QSqlIndex());/*{{{*/
    /**
     * Reset this column with the information in the passed field.
     * @param field \c QSqlField with new information to reset this column.
     * @param index \c QSqlIndex with the origin table or query index
     * information. This parameter is optional. When passed it is used to set
     * flags used in the result of #indexed() and #primaryKey() member
     * functions.
     * @since 1.2
     **/
    void reset(const QSqlField &field, const QSqlIndex &index = QSqlIndex());
    /*}}}*/
    // bool commit(QSqlRecord *record);/*{{{*/
    /**
     * Commits the value of this column to a field in the passed record.
     * @param record \c QSqlRecord to be updated.
     * @return \b true means the value was set. \b false is returned when the
     * \c QSqlRecord object doesn't have a field with the same name as this
     * column object.
     * @since 1.2
     **/
    bool commit(QSqlRecord *record);
    /*}}}*/
    //@}
public:
    /** @name Overloaded Operators */ //@{
    // column_t& operator =(const QSqlField &field);/*{{{*/
    /**
     * Assignment operator.
     * @param field The \c QSqlField object with the original data.
     * @return This operation returns \b this.
     * @remarks The result of this operation is the same as calling the member
     * function #reset() without the last parameter.
     * @since 1.2
     **/
    column_t& operator =(const QSqlField &field);
    /*}}}*/
    // column_t& operator =(const column_t &column);/*{{{*/
    /**
     * Copy operator.
     * @param column Another \c column_t object to copy its properties. All
     * data will be duplicated.
     * @returns \b this.
     * @since 1.2
     **/
    column_t& operator =(const column_t &column);
    /*}}}*/
    //@}
public:
    /** @name Data Members */ //@{
    // QString  name;/*{{{*/
    /**
     * This column name.
     * The name can be retrieved from the original table or from the \c SELECT
     * statement used to populate a recordset.
     * @since 1.2
     **/
    QString  name;
    /*}}}*/
    // QVariant value;/*{{{*/
    /**
     * This column value.
     * @since 1.2
     **/
    QVariant value;
    /*}}}*/
    // size_t   length;/*{{{*/
    /**
     * Named length of this column in the database.
     * Not always available. In these cases will be zero.
     * @since 1.2
     **/
    size_t   length;
    /*}}}*/
    // uint     flags;/*{{{*/
    /**
     * Hold information about this column.
     * This member is a tuple where bits have different meanings. It is used
     * as follows:
     * -# The most significant byte will have the data type of this column.
     *    A value retrieved from the @ref ssqt_dao_constants module.
     * -# The less significant byte of the most significant word has
     *    a combination of flags settings this column as \e required, \e
     *    read-only, \e indexed, etc.
     * -# The less significant word has the precision of the value when it is
     *    a fixed floating point number.
     * .
     * These properties are easily retrieved by the member functions
     * #dataType(), #required(), #precision(), etc...
     * @since 1.2
     **/
    uint     flags;
    /*}}}*/
    //@}
};
/* Inline Functions {{{ */
/* ---------------------------------------------------------------------------
 * Constructors {{{
 * ------------------------------------------------------------------------ */
// inline column_t::column_t(const QString &fieldName, QVariant::Type type);/*{{{*/
inline column_t::column_t(const QString &fieldName, QVariant::Type type) :
    SSSharedT<column_t>(), name(fieldName), length(0), flags(0) {
    dataType(type);
}
/*}}}*/
// inline column_t::column_t(const column_t &column);/*{{{*/
inline column_t::column_t(const column_t &column) : SSSharedT<column_t>(),
    name(column.name), value(column.value), length(column.length),
    flags(column.flags) { }
/*}}}*/
// inline column_t::column_t(const QSqlField &field, const QSqlIndex &index = QSqlIndex());/*{{{*/
inline column_t::column_t(const QSqlField &field, const QSqlIndex &index) :
    SSSharedT<column_t>() { reset(field, index); }
/*}}}*/
// Constructors }}}
/* ---------------------------------------------------------------------------
 * Attributes {{{
 * ------------------------------------------------------------------------ */
// inline bool column_t::required() const;/*{{{*/
inline bool column_t::required() const {
    return (flags & SS_COLUMN_REQUIRED);
}
/*}}}*/
// inline bool column_t::readOnly() const;/*{{{*/
inline bool column_t::readOnly() const {
    return (flags & SS_COLUMN_READONLY);
}
/*}}}*/
// inline bool column_t::autoValue() const;/*{{{*/
inline bool column_t::autoValue() const {
    return (flags & SS_COLUMN_AUTO);
}
/*}}}*/
// inline bool column_t::indexed() const;/*{{{*/
inline bool column_t::indexed() const {
    return (flags & SS_COLUMN_INDEXED);
}
/*}}}*/
// inline bool column_t::primaryKey() const;/*{{{*/
inline bool column_t::primaryKey() const {
    return (flags & SS_COLUMN_PKEY);
}
/*}}}*/
// inline bool column_t::isNull() const;/*{{{*/
inline bool column_t::isNull() const {
    return !value.isValid();
}
/*}}}*/
// Attributes }}}
/* ---------------------------------------------------------------------------
 * Properties {{{
 * ------------------------------------------------------------------------ */
// inline uint column_t::dataType() const;/*{{{*/
inline uint column_t::dataType() const {
    return (flags & 0x000000FF);
}
/*}}}*/
// inline void column_t::dataType(uint type);/*{{{*/
inline void column_t::dataType(uint type) {
    uint temp = (flags & 0xFFFFFF00);
    flags = (temp | (type & 0x000000FF));
}
/*}}}*/
// inline int  column_t::precision() const;/*{{{*/
inline int  column_t::precision() const {
    return ((flags & 0xFFFF0000) >> 16);
}
/*}}}*/
// Properties }}}
/* ---------------------------------------------------------------------------
 * Overloaded Operators {{{
 * ------------------------------------------------------------------------ */
// inline column_t& column_t::operator =(const QSqlField &field);/*{{{*/
inline column_t& column_t::operator =(const QSqlField &field) {
    reset(field); return *this;
}
/*}}}*/
// inline column_t& column_t::operator =(const column_t &column);/*{{{*/
inline column_t& column_t::operator =(const column_t &column) {
    name = column.name; value = column.value;
    length = column.length; flags = column.flags;
    return *this;
}
/*}}}*/
// Overloaded Operators }}}
/* ------------------------------------------------------------------------ */
/* }}} Inline Functions */
};
#endif /* __COLUMN_HPP_DEFINED__ */
