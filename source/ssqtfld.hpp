/**
 * @file
 * Declares the SSField class.
 *
 * @author Alessandro Antonello <aantonello@paralaxe.com.br>
 * @date   dezembro 09, 2014
 * @since  Super Simple for Qt 5 1.2
 *
 * \copyright
 * This file is provided in hope that it will be useful to someone. It is
 * offered in public domain. You may use, modify or distribute it freely.
 *
 * The code is provided "AS IS". There is no warranty at all, of any kind. You
 * may change it if you like. Or just use it as it is.
 */
#ifndef __SSQTFLD_HPP_DEFINED__
#define __SSQTFLD_HPP_DEFINED__

namespace ss {
    class column_t;
};

/**
 * \ingroup ssqt_dao
 * Represents a column in the database or table.
 * A \c SSField object kept its data using a pointer to a \c QSqlField object
 * retrieved from the connection with the database. Because of this pointer
 * reference every operation done in the objects of this library are made
 * through pointer so the manager object can own the original reference.
 * @since 1.2
 *//* --------------------------------------------------------------------- */
class SSField
{
public:
    /** @name Constructors & Destructor */ //@{
    // explicit SSField(const QString &fieldName = QString(), QVariant::Type type = QVariant::Invalid);/*{{{*/
    /**
     * Constructs a field object with the specified name and type.
     * @param fieldName The field name.
     * @param type Type for the field value. Values are kept in \c QVariant
     * object.
     * @remarks If this field has no name it can be searched only by its index
     * in the recordset collection. If no type if specified the field becomes
     * invalid.
     * @since 1.2
     **/
    explicit SSField(const QString &fieldName = QString(), QVariant::Type type = QVariant::Invalid);
    /*}}}*/
    // SSField(const SSField &field);/*{{{*/
    /**
     * Copy constructor.
     * @param field Another field to copy its properties and value.
     * @remarks An \c SSField object keeps its data in a pointer to the
     * original \c QSqlField object. Using this constructor (or the overloaded
     * operator =), both objects will have a reference to the same origin.
     * Changes in one instance will be reflected in another instance
     * immediately. Care must be taken.
     * @since 1.2
     **/
    SSField(const SSField &field);
    /*}}}*/
    // SSField(const QSqlField &field);/*{{{*/
    /**
     * Assignment constructor.
     * @param field The original \c QSqlField object.
     * @since 1.2
     **/
    SSField(const QSqlField &field);
    /*}}}*/
    // virtual ~SSField();/*{{{*/
    /**
     * Default destructor.
     * @since 1.2
     **/
    virtual ~SSField();
    /*}}}*/
    //@}

public:
    /** @name Attributes */ //@{
    // bool valid() const;/*{{{*/
    /**
     * Checks the validity of this object.
     * @returns \b true when this object is valid. \b false otherwise.
     * @remarks The object becomes invalid when its \c QSqlField origin object
     * is reclamed or destroied. Also when the value type is invalid, this
     * operation returns \b false.
     * @since 1.2
     **/
    bool valid() const;
    /*}}}*/
    // bool autoValue() const;/*{{{*/
    /**
     * Retrieves when the column represented by this field object has its
     * value authomatic generated by the database engine.
     * @returns \b true when the value is auto-generated. \b false otherwise.
     * @remarks The result of this operation is dependent of the database
     * driver and not always the returned information is accurate.
     * @since 1.2
     **/
    bool autoValue() const;
    /*}}}*/
    // bool readOnly() const;/*{{{*/
    /**
     * Retrieves when the value of the column represented by this field is
     * read-only.
     * @returns \b true when the value cannot be changed. \b false otherwise.
     * @remarks Read only fields are retrieved when a read only query is the
     * source of the data. Running a database view or stored procedure for
     * example.
     * @since 1.2
     **/
    bool readOnly() const;
    /*}}}*/
    // bool required() const;/*{{{*/
    /**
     * Checks whether the value of this field column is required.
     * @return \b true when the user is obligated to set a value for this
     * field's column. Otherwise \b false.
     * @remarks The result of this operation is meaningful only in new records
     * when the field has no value yet.
     * @since 1.2
     **/
    bool required() const;
    /*}}}*/
    // bool isNull() const;/*{{{*/
    /**
     * Checks whether the value of this field's column is null.
     * @return \b true if the value has no meaning. Otherwise \b false.
     * @remarks Every database driver treats null values different. The Qt
     * library translates the database null value to the C++ \b NULL constant.
     * When a null field value is converted to other type, like an \b int or
     * \b QString the operation will return a suitable value like a \b
     * 0 (zero) or empty string.
     * @since 1.2
     **/
    bool isNull() const;
    /*}}}*/
    // bool empty() const;/*{{{*/
    /**
     * Checks whether the value of this field's column is empty.
     * @return \b true if the value is empty, otherwise \b false.
     * @remarks This operation is meaningful when this field's column
     * type is a string. It will check the nulidity of the value and if the
     * string content is empty. The result will take the following path:
     * -# When the value is null (see #isNull()) the operation returns \b
     *    true.
     * -# When the value type is not a string the function returns \b false.
     * -# When the string is zero length the operation returns \b true.
     *    Otherwise \b false.
     * .
     * @since 1.2
     **/
    bool empty() const;
    /*}}}*/
    // QString name() const;/*{{{*/
    /**
     * Name of this field in the query or table.
     * @returns \c QString with this field name.
     * @since 1.2
     **/
    QString name() const;
    /*}}}*/
    // size_t  length() const;/*{{{*/
    /**
     * Retrieves this field length.
     * @return The length of the data held in this field.
     * @remarks For some drivers this information is not available. In these
     * cases the function will return zero. For some field types the value
     * returned is a count of bytes. For others types the result is counted in
     * characters. For string types the returned value never includes the null
     * terminator.
     * @since 1.2
     **/
    size_t  length() const;
    /*}}}*/
    // size_t  precision() const;/*{{{*/
    /**
     * Retrieves the precision of this field's value.
     * @returns Un integer with this field's value precision.
     * @remarks This information is useful only for numeric fields that has
     * floating point data. For others types, the result of this operation is
     * always zero.
     * @since 1.2
     **/
    size_t  precision() const;
    /*}}}*/
    // uint    type() const;/*{{{*/
    /**
     * This field's value type.
     * @return A type constant declared in the @ref ssqt_dao_constants module.
     * @remarks When the member function #valid() returns \b false the result
     * of this operation is zero.
     * @since 1.2
     **/
    uint type() const;
    /*}}}*/
    //@}

public:
    /** @name Properties */ //@{
    // QVariant value() const;/*{{{*/
    /**
     * Retrieves the value of this field.
     * @return A \c QVariant object with this field's value.
     * @since 1.2
     **/
    QVariant value() const;
    /*}}}*/
    // void value(const QVariant &val);/*{{{*/
    /**
     * Sets or changes the value of this field.
     * @param val A \c QVariant object with the field's value. The operation
     * tries to convert this \c QVariant into the specified type when data has
     * to be written in the database.
     * @since 1.2
     **/
    void value(const QVariant &val);
    /*}}}*/
    //@}

public:
    /** @name Value Conversion */ //@{
    // QByteArray asByteArray() const;/*{{{*/
    /**
     * Gets the value of this field as a byte array.
     * @return A \c QByteArray object with the value of this field in binary
     * format. If this field is \b NULL or empty the result will be an empty
     * \c QByteArray object.
     * @since 1.2
     **/
    QByteArray asByteArray() const;
    /*}}}*/
    // QString    asString() const;/*{{{*/
    /**
     * Gets the value of this field as an string.
     * @return A \c QString object with the value of this field.
     * @remarks When the field value is numeric it will be converted to its
     * textual representation. That is, the number 10.1 will be converted to
     * the string "10.1".
     * @note The conversion doesn't take locale into account.
     * @since 1.2
     **/
    QString    asString() const;
    /*}}}*/
    // double     asFloat() const;/*{{{*/
    /**
     * Retrieves this field's value in a floating point number.
     * @return The value os the field as a \b double.
     * @remarks When the field type is not numeric the result is zero.
     * @since 1.2
     **/
    double     asFloat() const;
    /*}}}*/
    // int64_t    asLong() const;/*{{{*/
    /**
     * Retrieves this field's value as a 64 bits integer.
     * @returns The \c int64_t value of this field.
     * @remarks When the field type is not numeric the result is zero.
     * @note "Long" here have the same meaning as in Java where \b long is
     * a 64 bits integer.
     * @since 1.2
     **/
    int64_t    asLong() const;
    /*}}}*/
    // int        asInt() const;/*{{{*/
    /**
     * Retrieves this field's value as an integer number.
     * @return The value of this field as an \b int.
     * @remarks When the field type is not numeric the result is zero.
     * @since 1.2
     **/
    int        asInt() const;
    /*}}}*/
    // QDateTime  asDateTime(const char *format = SS_DB_DATETIME_FORMAT) const;/*{{{*/
    /**
     * Get the value of this field as a \c QDateTime object.
     * @param format The format of the value stored in the database. Usually
     * this is equals to \c SS_DB_DATETIME_FORMAT value. Can be \b NULL. In
     * this case the operation will not try to parse the value.
     * @returns When succeeded the result is a \c QDateTime object with the
     * date and time retrieved from this field's value. Otherwise a default
     * constructed \c QDateTime object will be returned.
     * @since 1.2
     **/
    QDateTime  asDateTime(const char *format = SS_DB_DATETIME_FORMAT) const;
    /*}}}*/
    // QDate      asDate(const char *format = SS_DB_DATE_FORMAT) const;/*{{{*/
    /**
     * Retrieves date information from this field's value.
     * @param format The format of the value stored in the database. Usually
     * this is equals to \c SS_DB_DATE_FORMAT value. Can be \b NULL. In
     * this case the operation will not try to parse the value.
     * @returns When succeeded the result is a \c QDate object with the
     * date and time retrieved from this field's value. Otherwise a default
     * constructed \c QDate object will be returned.
     * @since 1.2
     **/
    QDate      asDate(const char *format = SS_DB_DATE_FORMAT) const;
    /*}}}*/
    // QTime      asTime(const char *format = SS_DB_TIME_FORMAT) const;/*{{{*/
    /**
     * Retrieves time information from this field's value.
     * @param format The format of the value stored in the database. Usually
     * this is equals to \c SS_DB_TIME_FORMAT value. Can be \b NULL. In
     * this case the operation will not try to parse the value.
     * @returns When succeeded the result is a \c QTime object with the
     * date and time retrieved from this field's value. Otherwise a default
     * constructed \c QTime object will be returned.
     * @since 1.2
     **/
    QTime      asTime(const char *format = SS_DB_TIME_FORMAT) const;
    /*}}}*/
    // QDateTime  asTimestamp() const;/*{{{*/
    /**
     * Retrieves date and time information from this field's value.
     * The information must be stored in a column of type \c
     * SS_DATA_TYPE_STAMP or \c SS_DATA_TYPE_INT.
     * @return A \c QDateTime object resulting of this field's value
     * conversion.
     * @note No time zone or offset is applied to the original value. It will
     * be converted as is.
     * @since 1.2
     **/
    QDateTime  asTimestamp() const;
    /*}}}*/
    //@}

public:
    /** @name Overloaded Operators */ //@{
    // operator bool() const;/*{{{*/
    /**
     * Cast this object to a \b bool type.
     * The resulting value is the same as calling the function #isNull() with
     * its result inverted. That is, when \c isNull() returns \b true this
     * operator returns \b false. When \c isNull() returns \b false this
     * operator returns \b true. This is a shortcut operation that can be used
     * in constructions like:
     * ~~~~~~~~~~~~{.cpp}
     * if (field) { ... }
     * ~~~~~~~~~~~~
     * Is the same as:
     * ~~~~~~~~~~~~{.cpp}
     * if (!field.isNull()) { ... }
     * ~~~~~~~~~~~~
     * @since 1.2
     **/
    operator bool() const;
    /*}}}*/
    // SSField& operator =(const SSField &field);/*{{{*/
    /**
     * Copy operator.
     * @param field Another \c SSField instance to copy.
     * @returns \b this.
     * @remarks Every \c SSField object hold its value in a pointer to the
     * original \c QSqlField object. This means that each copy of a \c SSField
     * object points to the same \c QSqlField object instance. Changes in one
     * \c SSField will be reflected on each copy.
     * @since 1.2
     **/
    SSField& operator =(const SSField &field);
    /*}}}*/
    // SSField& operator =(const QString &val);/*{{{*/
    /**
     * Sets or changes the value of this field.
     * @param val A \c QString object to be used as value for this field. If
     * this field is not of string type the operation will try to convert the
     * value into this field's type. On failure nothing happens.
     * @return The operation returns \b this.
     * @since 1.2
     **/
    SSField& operator =(const QString &val);
    /*}}}*/
    // SSField& operator =(double val);/*{{{*/
    /**
     * Sets or changes the value of this field.
     * @param val Value for the field. When this field is not of a numeric
     * type but is a string type the conversion is authomatic. If the
     * conversion fails the operation does nothing.
     * @return The operation returns \b this.
     * @since 1.2
     **/
    SSField& operator =(double val);
    /*}}}*/
    // SSField& operator =(int val);/*{{{*/
    /**
     * Sets or changes the value of this field.
     * @param val Value for the field. When this field is not of a numeric
     * type but is a string type the conversion is authomatic. If the
     * conversion fails the operation does nothing.
     * @return The operation returns \b this.
     * @since 1.2
     **/
    SSField& operator =(int val);
    /*}}}*/
    //@}

private:
    ss::column_t *m_column;             /**< Original data column.          */
};
/* Inline Functions {{{ */
/* ---------------------------------------------------------------------------
 * Public: Value Conversion {{{
 * ------------------------------------------------------------------------ */
// inline QByteArray SSField::asByteArray() const;/*{{{*/
inline QByteArray SSField::asByteArray() const {
    return value().toByteArray();
}
/*}}}*/
// inline QString    SSField::asString() const;/*{{{*/
inline QString    SSField::asString() const {
    return value().toString();
}
/*}}}*/
// inline double     SSField::asFloat() const;/*{{{*/
inline double     SSField::asFloat() const {
    return value().toDouble();
}
/*}}}*/
// inline int64_t    SSField::asLong() const;/*{{{*/
inline int64_t    SSField::asLong() const {
    return value().toLongLong();
}
/*}}}*/
// inline int        SSField::asInt() const;/*{{{*/
inline int        SSField::asInt() const {
    return value().toInt();
}
/*}}}*/
// inline QDateTime  SSField::asDateTime(const char *format = SS_DB_DATETIME_FORMAT) const;/*{{{*/
inline QDateTime  SSField::asDateTime(const char *format) const {
    return ((format) ? QDateTime::fromString(asString(), format) : value().toDateTime());
}
/*}}}*/
// inline QDate      SSField::asDate(const char *format = SS_DB_DATE_FORMAT) const;/*{{{*/
inline QDate      SSField::asDate(const char *format) const {
    return ((!format) ? value().toDate() : QDate::fromString(asString(), format));
}
/*}}}*/
// inline QTime      SSField::asTime(const char *format = SS_DB_TIME_FORMAT) const;/*{{{*/
inline QTime      SSField::asTime(const char *format) const {
    return ((!format) ? value().toTime() : QTime::fromString(asString(), format));
}
/*}}}*/
// inline QDateTime  SSField::asTimestamp() const;/*{{{*/
inline QDateTime  SSField::asTimestamp() const {
    return QDateTime::fromMSecsSinceEpoch((qint64)asLong());
}
/*}}}*/
// Public: Value Conversion }}}
/* ---------------------------------------------------------------------------
 * Overloaded Operators {{{
 * ------------------------------------------------------------------------ */
// inline SSField::operator bool() const;/*{{{*/
inline SSField::operator bool() const {
    return isNull();
}
/*}}}*/
// inline SSField& SSField::operator =(const QString &val);/*{{{*/
inline SSField& SSField::operator =(const QString &val) {
    value( QVariant(val) ); return *this;
}
/*}}}*/
// inline SSField& SSField::operator =(double val);/*{{{*/
inline SSField& SSField::operator =(double val) {
    value(QVariant(val)); return *this;
}
/*}}}*/
// inline SSField& SSField::operator =(int val);/*{{{*/
inline SSField& SSField::operator =(int val) {
    value( QVariant(val) ); return *this;
}
/*}}}*/
// Overloaded Operators }}}
/* ------------------------------------------------------------------------ */
/* }}} Inline Functions */
#endif /* __SSQTFLD_HPP_DEFINED__ */
