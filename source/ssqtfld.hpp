/**
 * @file
 * Declares the SSField class.
 *
 * @author Alessandro Antonello <aantonello@paralaxe.com.br>
 * @date   dezembro 09, 2014
 * @since  Super Simple for Qt 5 1.2
 *
 * \copyright
 * This file is provided in hope that it will be useful to someone. It is
 * offered in public domain. You may use, modify or distribute it freely.
 *
 * The code is provided "AS IS". There is no warranty at all, of any kind. You
 * may change it if you like. Or just use it as it is.
 */
#ifndef __SSQTFLD_HPP_DEFINED__
#define __SSQTFLD_HPP_DEFINED__

#include <QSql>

/**
 * Represents a column in the database or table.
 * A \c SSField object kept its data using a pointer to a \c QSqlField object
 * retrieved from the connection with the database. Because of this pointer
 * reference every operation done in the objects of this library are made
 * through pointer so the manager object can own the original reference.
 * @since 1.2
 *//* --------------------------------------------------------------------- */
class SSField
{
public:
    /** @name Constructors & Destructor */ //@{
    // explicit SSField(const QString &fieldName = QString(), QVariant::Type type = QVariant::Invalid);/*{{{*/
    /**
     * Constructs a field object with the specified name and type.
     * @param fieldName The field name.
     * @param type Type for the field value. Values are kept in \c QVariant
     * object.
     * @remarks If this field has no name it can be searched only by its index
     * in the recordset collection. If no type if specified the field becomes
     * invalid.
     * @since 1.2
     **/
    explicit SSField(const QString &fieldName = QString(), QVariant::Type type = QVariant::Invalid);
    /*}}}*/
    // SSField(const SSField &field);/*{{{*/
    /**
     * Copy constructor.
     * @param field Another field to copy its properties and value.
     * @remarks An \c SSField object keeps its data in a pointer to the
     * original \c QSqlField object. Using this constructor (or the overloaded
     * operator =), both objects will have a reference to the same origin.
     * Changes in one instance will be reflected in another instance
     * immediately. Care must be taken.
     * @since 1.2
     **/
    SSField(const SSField &field);
    /*}}}*/
    // SSField(QSqlField *field);/*{{{*/
    /**
     * Assignment constructor.
     * @param field The original \c QSqlField object.
     * @since 1.2
     **/
    SSField(QSqlField *field);
    /*}}}*/
    //@}

public:
    /** @name Attributes */ //@{
    // bool valid() const;/*{{{*/
    /**
     * Checks the validity of this object.
     * @returns \b true when this object is valid. \b false otherwise.
     * @remarks The object becomes invalid when its \c QSqlField origin object
     * is reclamed or destroied. Also when the value type is invalid, this
     * operation returns \b false.
     * @since 1.2
     **/
    bool valid() const;
    /*}}}*/
    // bool autoValue() const;/*{{{*/
    /**
     * Retrieves when the column represented by this field object has its
     * value authomatic generated by the database engine.
     * @returns \b true when the value is auto-generated. \b false otherwise.
     * @remarks The result of this operation is dependent of the database
     * driver and not always the returned information is accurate.
     * @since 1.2
     **/
    bool autoValue() const;
    /*}}}*/
    // bool readOnly() const;/*{{{*/
    /**
     * Retrieves when the value of the column represented by this field is
     * read-only.
     * @returns \b true when the value cannot be changed. \b false otherwise.
     * @remarks Read only fields are retrieved when a read only query is the
     * source of the data. Running a database view or stored procedure for
     * example.
     * @since 1.2
     **/
    bool readOnly() const;
    /*}}}*/
    // bool required() const;/*{{{*/
    /**
     * Checks whether the value of this field column is required.
     * @return \b true when the user is obligated to set a value for this
     * field's column. Otherwise \b false.
     * @remarks The result of this operation is meaningful only in new records
     * when the field has no value yet.
     * @since 1.2
     **/
    bool required() const;
    /*}}}*/
    // bool isNull() const;/*{{{*/
    /**
     * Checks whether the value of this field's column is null.
     * @return \b true if the value has no meaning. Otherwise \b false.
     * @remarks Every database driver treats null values different. The Qt
     * library translates the database null value to the C++ \b NULL constant.
     * When a null field value is converted to other type, like an \b int or
     * \b QString the operation will return a suitable value like a \b
     * 0 (zero) or empty string.
     * @since 1.2
     **/
    bool isNull() const;
    /*}}}*/
    // bool empty() const;/*{{{*/
    /**
     * Checks whether the value of this field's column is empty.
     * @return \b true if the value is empty, otherwise \b false.
     * @remarks This operation is meaningful when this field's column
     * type is a string. It will check the nulidity of the value and if the
     * string content is empty. The result will take the following path:
     * -# When the value is null (see #isNull()) the operation returns \b
     *    true.
     * -# When the value type is not a string the function returns \b false.
     * -# When the string is zero length the operation returns \b true.
     *    Otherwise \b false.
     * .
     * @since 1.2
     **/
    bool empty() const;
    /*}}}*/
    // QString name() const;/*{{{*/
    /**
     * Name of this field in the query or table.
     * @returns \c QString with this field name.
     * @since 1.2
     **/
    QString name() const;
    /*}}}*/
    // size_t  length() const;/*{{{*/
    /**
     * Retrieves this field length.
     * @return The length of the data held in this field.
     * @remarks For some drivers this information is not available. In these
     * cases the function will return zero. For some field types the value
     * returned is a count of bytes. For others types the result is counted in
     * characters. For string types the returned value never includes the null
     * terminator.
     * @since 1.2
     **/
    size_t  length() const;
    /*}}}*/
    // size_t  precision() const;/*{{{*/
    /**
     * Retrieves the precision of this field's value.
     * @returns Un integer with this field's value precision.
     * @remarks This information is useful only for numeric fields that has
     * floating point data. For others types, the result of this operation is
     * always zero.
     * @since 1.2
     **/
    size_t  precision() const;
    /*}}}*/
    // QVariant::Type type() const;/*{{{*/
    /**
     * This field's value type.
     * @return An enumeration value defining this field's value type.
     * @remarks Although the enumeration is realy big, the value type is
     * constrained by the database driver in a small subset. When the result
     * of this operation is \c QVariant::Invalid the function #valid() returns
     * \b false.
     * @since 1.2
     **/
    QVariant::Type type() const;
    /*}}}*/
    //@}

public:
    /** @name Properties */ //@{
    // QVariant value() const;/*{{{*/
    /**
     * Retrieves the value of this field.
     * @return A \c QVariant object with this field's value.
     * @since 1.2
     **/
    QVariant value() const;
    /*}}}*/
    // void value(const QVariant &val);/*{{{*/
    /**
     * Sets or changes the value of this field.
     * @param val A \c QVariant object with the field's value. The operation
     * tries to convert this \c QVariant into the specified type when data has
     * to be written in the database.
     * @since 1.2
     **/
    void value(const QVariant &val);
    /*}}}*/
    //@}

public:
    /** @name Value Conversion */ //@{
    // QByteArray asByteArray() const;/*{{{*/
    /**
     * Gets the value of this field as a byte array.
     * @return A \c QByteArray object with the value of this field in binary
     * format. If this field is \b NULL or empty the result will be an empty
     * \c QByteArray object.
     * @since 1.2
     **/
    QByteArray asByteArray() const;
    /*}}}*/
    // QString    asString() const;/*{{{*/
    /**
     * Gets the value of this field as an string.
     * @return A \c QString object with the value of this field.
     * @remarks When the field value is numeric it will be converted to its
     * textual representation. That is, the number 10.1 will be converted to
     * the string "10.1".
     * @note The conversion doesn't take locale into account.
     * @since 1.2
     **/
    QString    asString() const;
    /*}}}*/
    // double     asFloat() const;/*{{{*/
    /**
     * Retrieves this field's value in a floating point number.
     * @return The value os the field as a \b double.
     * @remarks When the field type is not numeric the result is zero.
     * @since 1.2
     **/
    double     asFloat() const;
    /*}}}*/
    // int64_t    asLong() const;/*{{{*/
    /**
     * Retrieves this field's value as an 64 bits integer.
     * @returns The \c int64_t value of this field.
     * @remarks When the field type is not numeric the result is zero.
     * @since 1.2
     **/
    int64_t    asLong() const;
    /*}}}*/
    // int        asInt() const;/*{{{*/
    /**
     * Retrieves this field's value as an integer number.
     * @return The value of this field as an \b int.
     * @remarks When the field type is not numeric the result is zero.
     * @since 1.2
     **/
    int        asInt() const;
    /*}}}*/
    //@}

public:
    /** @name Overloaded Operators */ //@{
    // operator bool() const;/*{{{*/
    /**
     * Cast this object to a \b bool type.
     * The resulting value is the same as calling the function #isNull() with
     * its result inverted. That is, when \c isNull() returns \b true this
     * operator returns \b false. When \c isNull() returns \b false this
     * operator returns \b true. This is a shortcut operation that can be used
     * in constructions like:
     * ~~~~~~~~~~~~{.cpp}
     * if (field) { ... }
     * ~~~~~~~~~~~~
     * Is the same as:
     * ~~~~~~~~~~~~{.cpp}
     * if (!field.isNull()) { ... }
     * ~~~~~~~~~~~~
     * @since 1.2
     **/
    operator bool() const;
    /*}}}*/
    // SSField& operator =(const SSField &field);/*{{{*/
    /**
     * Copy operator.
     * @param field Another \c SSField instance to copy.
     * @returns \b this.
     * @remarks Every \c SSField object hold its value in a pointer to the
     * original \c QSqlField object. This means that each copy of a \c SSField
     * object points to the same \c QSqlField object instance. Changes in one
     * \c SSField will be reflected on each copy.
     * @since 1.2
     **/
    SSField& operator =(const SSField &field);
    /*}}}*/
    // SSField& operator =(const QString &val);/*{{{*/
    /**
     * Sets or changes the value of this field.
     * @param val A \c QString object to be used as value for this field. If
     * this field is not of string type the operation will try to convert the
     * value into this field's type. On failure nothing happens.
     * @return The operation returns \b this.
     * @since 1.2
     **/
    SSField& operator =(const QString &val);
    /*}}}*/
    // SSField& operator =(double val);/*{{{*/
    /**
     * Sets or changes the value of this field.
     * @param val Value for the field. When this field is not of a numeric
     * type but is a string type the conversion is authomatic. If the
     * conversion fails the operation does nothing.
     * @return The operation returns \b this.
     * @since 1.2
     **/
    SSField& operator =(double val);
    /*}}}*/
    // SSField& operator =(int val);/*{{{*/
    /**
     * Sets or changes the value of this field.
     * @param val Value for the field. When this field is not of a numeric
     * type but is a string type the conversion is authomatic. If the
     * conversion fails the operation does nothing.
     * @return The operation returns \b this.
     * @since 1.2
     **/
    SSField& operator =(int val);
    /*}}}*/
    //@}

protected:
    QSqlField *m_field;                 /**< The original data pointer.     */
};
/* Inline Functions {{{ */
/* ---------------------------------------------------------------------------
 * Constructors & Destructor {{{
 * ------------------------------------------------------------------------ */
// inline SSField::SSField(const QString &fieldName = QString(), QVariant::Type type = QVariant::Invalid);/*{{{*/
inline SSField::SSField(const QString &fieldName, QVariant::Type type) :
    m_field(new QSqlField(fieldName, type)) { }
/*}}}*/
// inline SSField::SSField(const SSField &field);/*{{{*/
inline SSField::SSField(const SSField &field) : m_field(field.m_field) { }
/*}}}*/
// inline SSField::SSField(QSqlField *field);/*{{{*/
inline SSField::SSField(QSqlField *field) : m_field(field) { }
/*}}}*/
// Constructors & Destructor }}}
/* ---------------------------------------------------------------------------
 * Attributes {{{
 * ------------------------------------------------------------------------ */
// inline bool SSField::valid() const;/*{{{*/
inline bool SSField::valid() const {
    return ((m_field != NULL) && m_field->isValid());
}
/*}}}*/
// inline bool SSField::autoValue() const;/*{{{*/
inline bool SSField::autoValue() const {
    return (valid() ? m_field->isAutoValue() : false);
}
/*}}}*/
// inline bool SSField::readOnly() const;/*{{{*/
inline bool SSField::readOnly() const {
    return (valid() ? m_field->isReadOnly() : true);
}
/*}}}*/
// inline bool SSField::required() const;/*{{{*/
inline bool SSField::required() const {
    return (valid() ? m_field->requiredStatus() == QSqlField::Required : false);
}
/*}}}*/
// inline bool SSField::isNull() const;/*{{{*/
inline bool SSField::isNull() const {
    return (valid() ? m_field->isNull() : true);
}
/*}}}*/
// inline bool SSField::empty() const;/*{{{*/
inline bool SSField::empty() const {
    if (isNull()) return true;
    return (((type() != QVariant::String) && (type() != QVariant::Char)) ?
            false : asString().isEmpty());
}
/*}}}*/
// inline QString SSField::name() const;/*{{{*/
inline QString SSField::name() const {
    return (valid() ? m_field->name() : QString());
}
/*}}}*/
// inline size_t  SSField::length() const;/*{{{*/
inline size_t  SSField::length() const {
    int size = (valid() ? m_field->length() : 0);
    return (size_t)((size < 0) ? 0 : size);
}
/*}}}*/
// inline size_t  SSField::precision() const;/*{{{*/
inline size_t  SSField::precision() const {
    int size = (valid() ? m_field->precision() : 0);
    return (size_t)((size < 0) ? 0 : size);
}
/*}}}*/
// inline QVariant::Type SSField::type() const;/*{{{*/
inline QVariant::Type SSField::type() const {
    return (valid() ? m_field->type() : QVariant::Invalid);
}
/*}}}*/
// Attributes }}}
/* ---------------------------------------------------------------------------
 * Properties {{{
 * ------------------------------------------------------------------------ */
// inline QVariant SSField::value() const;/*{{{*/
inline QVariant SSField::value() const {
    return (valid() ? m_field->value() : QVariant());
}
/*}}}*/
// inline void SSField::value(const QVariant &val);/*{{{*/
inline void SSField::value(const QVariant &val) {
    if (!valid()) return;
    m_field->setValue( val );
}
/*}}}*/
// Properties }}}
/* ---------------------------------------------------------------------------
 * Value Conversion {{{
 * ------------------------------------------------------------------------ */
// inline QByteArray SSField::asByteArray() const;/*{{{*/
inline QByteArray SSField::asByteArray() const {
    return value().toByteArray();
}
/*}}}*/
// inline QString    SSField::asString() const;/*{{{*/
inline QString    SSField::asString() const {
    return value().toString();
}
/*}}}*/
// inline double     SSField::asFloat() const;/*{{{*/
inline double     SSField::asFloat() const {
    return value().toDouble();
}
/*}}}*/
// inline int64_t    SSField::asLong() const;/*{{{*/
inline int64_t    SSField::asLong() const {
    return value().toLongLong();
}
/*}}}*/
// inline int        SSField::asInt() const;/*{{{*/
inline int        SSField::asInt() const {
    return value().toInt();
}
/*}}}*/
// Value Conversion }}}
/* ---------------------------------------------------------------------------
 * Overloaded Operators {{{
 * ------------------------------------------------------------------------ */
// inline SSField::operator bool() const;/*{{{*/
inline SSField::operator bool() const {
    return isNull();
}
/*}}}*/
// inline SSField& SSField::operator =(const SSField &field);/*{{{*/
inline SSField& SSField::operator =(const SSField &field) {
    m_field = field.m_field; return *this;
}
/*}}}*/
// inline SSField& SSField::operator =(const QString &val);/*{{{*/
inline SSField& SSField::operator =(const QString &val) {
    value( QVariant(val) ); return *this;
}
/*}}}*/
// inline SSField& SSField::operator =(double val);/*{{{*/
inline SSField& SSField::operator =(double val) {
    value(QVariant(val)); return *this;
}
/*}}}*/
// inline SSField& SSField::operator =(int val);/*{{{*/
inline SSField& SSField::operator =(int val) {
    value( QVariant(val) ); return *this;
}
/*}}}*/
// Overloaded Operators }}}
/* ------------------------------------------------------------------------ */
/* }}} Inline Functions */
#endif /* __SSQTFLD_HPP_DEFINED__ */
